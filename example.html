<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <!--[if IE]><script type="text/javascript" src="excanvas.js"></script><![endif]-->
  <script type="text/javascript" src='javascript/SurfacePlot.js'></script>
  <script type="text/javascript" src='javascript/ColourGradient.js'></script>
  
  <script type="text/javascript" src="javascript/glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript" src="javascript/webgl-utils.js"></script>
  <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjs/1.4.0/math.min.js"></script>
  <script src="assets/bower_components/webcomponentsjs/webcomponents.min.js"></script>
  <link rel="import" href="assets/bower_components/paper-slider/paper-slider.html">
  
  <style>
      #paper_slider {
        left: 520px;
        top: 220px;
      }
    </style>
  <title>SurfacePlot test stub</title>
  
  <script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec3 vLightWeighting;
    
    void main(void)
    {
    gl_FragColor = vec4(vColor.rgb * vLightWeighting, vColor.a);
    }
  </script>
  
  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aVertexColor;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    varying vec4 vColor;
    
    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;
    varying vec3 vLightWeighting;
    
    void main(void)
    {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    
    vec3 transformedNormal = uNMatrix * aVertexNormal;
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
    vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting; 
    
    vColor = aVertexColor;
    }
  </script>
  
  <script id="axes-shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 vColor;
    
    void main(void)
    {
    gl_FragColor = vColor;
    }
  </script>
  
  <script id="axes-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec4 vColor;
    uniform vec3 uAxesColour;
    
    void main(void)
    {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vColor =  vec4(uAxesColour, 1.0);
    } 
  </script>
  
  <script id="texture-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec2 vTextureCoord;
    
    uniform sampler2D uSampler;
    
    void main(void)
    {
    gl_FragColor = texture2D(uSampler, vTextureCoord);
    }
  </script>
  
  <script id="texture-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    
    attribute vec2 aTextureCoord;
    varying vec2 vTextureCoord;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    void main(void)
    {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord; 
    }
  </script>
  
  
</head>
<body style="background:#000">

    <paper-slider editable value="-1.5" min="-3" max="3" step="0.1" id="paper_slider"></paper-slider>

<div style="margin-left: 50px;">
  <div>
    <span style="color: #ffffff">Press the shift key and drag the mouse to scale the surface plot.</span>
  </div>
  
  <div style="clear: right;">
    <div id='surfacePlotDiv' style="float: left; width: 450px; height: 450px; border:1px solid red; background: #fff;">
      <!-- SurfacePlot goes here... -->
    </div>
  </div>
  
  <div style="clear: both;">
    <br>
      <br>
	<form action="">
	  <input type="button" name="animate" value="animate" onclick="animateCharts();"> 
	    <span id="Hey" style="color: #ffffff">(applies to webGL only)</span>
	  </form>
	</div>
      </div>
      
      <script type='text/javascript'>
	
	var surfacePlot;
	var data, options, basicPlotOptions, glOptions, animated, plot1, values;
	
	function setUp()
	{
	//alert(math.sqrt(-4));
	
	var sigma = math.matrix([[1, 0], [0, 1]]);
	var inv_sigma = math.inv(sigma);
	var det_sigma = math.abs(math.det(sigma));
	var mu = math.matrix([[0],[0]]);
	
	var numRows = 45;
	var numCols = 45;
	
	var tooltipStrings = new Array();
	values = new Array();
	data = {nRows: numRows, nCols: numCols, formattedValues: values};
	
	var d = 360 / numRows;
	var idx = 0;
	
	for (var i = 0; i < numRows; i++) 
	  {
	  values[i] = new Array();
	  var x = (i*6/45)-3;
	  
	  for (var j = 0; j < numCols; j++)
	    {
	    var y = (j*6/45)-3;
	    //var value = (Math.cos(i * d * Math.PI / 180.0) * Math.cos(j * d * Math.PI / 180.0) + Math.sin(i * d * Math.PI / 180.0));
	    var f1 = 1.0/(math.sqrt(math.pow(2*math.pi, 2)*det_sigma));
	    //alert(f1);
	    var x_m_u = math.subtract(math.matrix([[x],[y]]), mu);
	    console.log("xmu: " + math.size(x_m_u));
	    console.log("inv_sigma: " + math.size(inv_sigma));
	    console.log("1 multi: " + math.size(math.multiply(math.transpose(x_m_u), inv_sigma)));
	    
	    
	    console.log("multi: " + math.size(math.multiply(math.multiply(math.transpose(x_m_u), inv_sigma), x_m_u)));
	    
	    var fe = -0.5*math.multiply(math.multiply(math.transpose(x_m_u), inv_sigma), x_m_u);
	    console.log(f1 + "," + fe + "," + math.exp(fe));
	    //alert(fe);
	    var value = f1*math.exp(fe);
	    console.log("(", + x + "," + y + "," + value +")");
	    
	    
	    values[i][j] = value;
	    
	    tooltipStrings[idx] = "x:" + x + ", y:" + y + " = " + value;
	    idx++;
	    }
	    }
	    
	    surfacePlot = new SurfacePlot(document.getElementById("surfacePlotDiv"));
	    
	    // Don't fill polygons in IE < v9. It's too slow.
	    var fillPly = true;
	    
	    // Define a colour gradient.
	    var colour1 = {red:0, green:0, blue:255};
	    var colour2 = {red:0, green:255, blue:255};
	    var colour3 = {red:0, green:255, blue:0};
	    var colour4 = {red:255, green:255, blue:0};
	    var colour5 = {red:255, green:0, blue:0};
	    var colours = [colour1, colour2, colour3, colour4, colour5];
	    
	    // Axis labels.
	    var xAxisHeader	= "X-axis";
	    var yAxisHeader	= "Y-axis";
	    var zAxisHeader	= "Z-axis";
	    
	    var renderDataPoints = false;
	    var background = '#ffffff';
	    var axisForeColour = '#000000';
	    var hideFloorPolygons = true;
	    var chartOrigin = {x: 150, y:150};
	    
	    // Options for the basic canvas pliot.
	    basicPlotOptions = {fillPolygons: fillPly, tooltips: tooltipStrings, renderPoints: renderDataPoints }
	    
	    // Options for the webGL plot.
	    var xLabels = [-3, -2, -1, 0, 1, 2, 3];
	    var yLabels = [-3, -2, -1, 0, 1, 2, 3];
	    var zLabels = [0, 0.1, 0.2, 0.3, 0.4]; // These labels ar eused when autoCalcZScale is false;
	    glOptions = {xLabels: xLabels, yLabels: yLabels, zLabels: zLabels, chkControlId: "allowWebGL", autoCalcZScale: false, animate: false};
	    
	    // Options common to both types of plot.
	    options = {xPos: 0, yPos: 0, width: 400, height: 400, colourGradient: colours, 
	    xTitle: xAxisHeader, yTitle: yAxisHeader, zTitle: zAxisHeader, 
	    backColour: background, axisTextColour: axisForeColour, hideFlatMinPolygons: hideFloorPolygons, origin: chartOrigin};
	    
	    surfacePlot.draw(data, options, basicPlotOptions, glOptions);
	    
	    }
	    
	    
	    
	    function animateCharts() {
	    
	    if (!animated) {
	    surfacePlot.draw(data2, options, basicPlotOptions2, glOptions2);
	    //surfacePlot2.draw(data, options, basicPlotOptions, glOptions);
	    animated = true;
	    }
	    else {
	    surfacePlot.draw(data, options, basicPlotOptions, glOptions);
	    //surfacePlot2.draw(data2, options, basicPlotOptions2, glOptions2);
	    animated = false;
	    }
	    
	    coordinateCharts();
	    
	    }
	    
	    setUp();
	    
	    function toggleChart(chkbox)
	    { 
	    surfacePlot.draw(data, options, basicPlotOptions, glOptions);
	    //surfacePlot2.draw(data2, options, basicPlotOptions2, glOptions2);
	    
	    coordinateCharts();
	    } 
	    
	  </script>
	  
	</body>
      </html>
      